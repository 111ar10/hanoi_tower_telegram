<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower of Hanoi</title>
    
    <!-- ‚úÖ Telegram WebApp SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <style>
        /* ... keep all your existing CSS ... */
        
        /* Just add this at the end of your CSS */
        .debug-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            color: #0f0;
            padding: 10px;
            font-family: monospace;
            font-size: 10px;
            max-height: 150px;
            overflow-y: auto;
            z-index: 3000;
            display: none; /* Change to 'block' to show debug */
        }
    </style>
</head>
<body>
    <!-- Keep all your existing HTML -->
    
    <!-- Add debug panel at the end of body -->
    <div class="debug-panel" id="debugPanel"></div>
    
    <script>
        // ============================================
        // DEBUG LOGGER
        // ============================================
        const debugPanel = document.getElementById('debugPanel');
        const DEBUG_MODE = true; // Set to false in production
        
        function debugLog(msg, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = {
                'info': '‚ÑπÔ∏è',
                'success': '‚úÖ',
                'error': '‚ùå',
                'warn': '‚ö†Ô∏è'
            }[type] || '‚ÑπÔ∏è';
            
            console.log(`[${timestamp}] ${msg}`);
            
            if (DEBUG_MODE && debugPanel) {
                debugPanel.innerHTML += `<br>${prefix} ${timestamp} ${msg}`;
                debugPanel.scrollTop = debugPanel.scrollHeight;
            }
        }
        
        // ============================================
        // TELEGRAM WEBAPP INITIALIZATION
        // ============================================
        
        debugLog('üöÄ Script starting...');
        
        // Check Telegram WebApp
        if (!window.Telegram?.WebApp) {
            debugLog('‚ùå Telegram WebApp not available!', 'error');
            alert('Error: This game must be opened from Telegram');
            throw new Error('Telegram WebApp not available');
        }
        
        const tg = window.Telegram.WebApp;
        debugLog('‚úÖ Telegram WebApp found', 'success');
        
        // Initialize
        tg.ready();
        tg.expand();
        tg.enableClosingConfirmation();
        debugLog('‚úÖ Telegram WebApp initialized', 'success');
        
        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const gameConfig = {
            sessionId: urlParams.get('sessionId'),
            userId: urlParams.get('userId'),
            difficulty: parseInt(urlParams.get('difficulty')) || 2,
            timeLimit: parseInt(urlParams.get('timeLimit')) || 300,
            minScore: parseInt(urlParams.get('minScore')) || 0,
            lang: urlParams.get('lang') || 'en'
        };
        
        debugLog(`üìç Session: ${gameConfig.sessionId}`, 'success');
        debugLog(`üë§ User: ${gameConfig.userId}`, 'success');
        debugLog(`üéØ Difficulty: ${gameConfig.difficulty}`, 'success');
        
        if (!gameConfig.sessionId) {
            debugLog('‚ùå No session ID!', 'error');
            alert('Error: Invalid game session');
            throw new Error('No session ID');
        }
        
        // ============================================
        // GAME STATE
        // ============================================
        
        const DISK_COUNT = Math.min(3 + gameConfig.difficulty, 7);
        const OPTIMAL_MOVES = Math.pow(2, DISK_COUNT) - 1;
        
        let gameState = {
            towers: [[], [], []],
            selectedTower: null,
            moves: 0,
            mistakes: 0,
            hintsUsed: 0,
            startTime: Date.now(),
            completed: false
        };
        
        // Initialize first tower with disks
        for (let i = DISK_COUNT; i >= 1; i--) {
            gameState.towers[0].push(i);
        }
        
        debugLog(`üéÆ Game initialized: ${DISK_COUNT} disks`, 'success');
        
        // ============================================
        // GAME LOGIC (Keep your existing functions)
        // ============================================
        
        // ... keep all your existing game functions ...
        // renderGame(), selectTower(), moveDisk(), etc.
        
        // ============================================
        // GAME COMPLETION
        // ============================================
        
        function checkWin() {
            return gameState.towers[2].length === DISK_COUNT;
        }
        
        function handleGameComplete() {
            debugLog('üéâ Game completed!', 'success');
            
            gameState.completed = true;
            const timeElapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
            
            // Calculate score
            const efficiency = Math.min(1, OPTIMAL_MOVES / gameState.moves);
            const timeBonus = gameConfig.timeLimit ? 
                Math.max(0, gameConfig.timeLimit - timeElapsed) * 10 : 0;
            
            const score = Math.max(0, Math.floor(
                (efficiency * 1000) + timeBonus - 
                (gameState.mistakes * 50) - 
                (gameState.hintsUsed * 100)
            ));
            
            // Calculate rating
            let rating = 'F';
            if (score >= 950) rating = 'S';
            else if (score >= 850) rating = 'A';
            else if (score >= 700) rating = 'B';
            else if (score >= 500) rating = 'C';
            else if (score >= 300) rating = 'D';
            
            debugLog(`Score: ${score}, Rating: ${rating}`, 'success');
            
            // Prepare result data
            const resultData = {
                sessionId: gameConfig.sessionId,
                gameId: 'hanoi',
                userId: gameConfig.userId,
                score: score,
                rating: rating,
                moves: gameState.moves,
                optimalMoves: OPTIMAL_MOVES,
                timeElapsed: timeElapsed,
                hintsUsed: gameState.hintsUsed,
                mistakes: gameState.mistakes,
                completed: true,
                difficulty: gameConfig.difficulty,
                numDisks: DISK_COUNT,
                timestamp: Date.now()
            };
            
            debugLog('üì¶ Sending result...', 'info');
            sendResultToBot(resultData);
        }
        
        // ============================================
        // SEND RESULT TO BOT
        // ============================================
        
        function sendResultToBot(resultData) {
            debugLog('üì§ Preparing to send data...', 'info');
            
            try {
                const dataString = JSON.stringify(resultData);
                debugLog(`üìè Data size: ${dataString.length} bytes`, 'info');
                
                if (dataString.length > 4096) {
                    debugLog('‚ö†Ô∏è Data too large!', 'warn');
                    // Trim if needed
                    delete resultData.towers;
                    const newString = JSON.stringify(resultData);
                    debugLog(`üìè Trimmed to: ${newString.length} bytes`, 'info');
                }
                
                debugLog('üì§ Calling tg.sendData()...', 'info');
                tg.sendData(JSON.stringify(resultData));
                debugLog('‚úÖ Data sent!', 'success');
                
                // Show success message
                alert(`üéâ Completed!\n\nScore: ${resultData.score}\nRating: ${resultData.rating}\n\nResult sent to bot!`);
                
                // Close after short delay
                setTimeout(() => {
                    debugLog('üîÑ Closing WebApp...', 'info');
                    tg.close();
                }, 2000);
                
            } catch (error) {
                debugLog(`‚ùå Send failed: ${error.message}`, 'error');
                alert('Error sending result: ' + error.message);
                console.error('Send error:', error);
            }
        }
        
        // ============================================
        // HOOK INTO YOUR EXISTING GAME
        // ============================================
        
        // Modify your existing win detection to call handleGameComplete()
        // For example, after a successful move:
        
        function onDiskMoved(from, to) {
            // ... your existing move logic ...
            
            if (checkWin()) {
                handleGameComplete();
            }
        }
        
        // ============================================
        // INITIALIZE GAME
        // ============================================
        
        // Call your existing game initialization
        // renderGame();
        // startTimer();
        // etc.
        
        debugLog('‚úÖ All systems ready!', 'success');
    </script>
</body>
</html>
